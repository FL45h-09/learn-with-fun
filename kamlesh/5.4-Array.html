<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Array</title>
</head>
<body>
    <script>

        // Array are used for storing ordered collections of elements, making it easy to access items by their index and manipulate their order. They come with various methods that facilitate operations like adding, removing, and sorting elements.

        // Step 1)

        let fruit = ["Apple", "Mango", "Grapes", "Kiwi"];
        // console.log(fruit[0]);
        // console.log(fruit[1]);
        // console.log(fruit[2]);
        // console.log(fruit[3]);

        // Step 2) It replaces element from index 0

        // fruit[0] = "Banana";
        // console.log(fruit)

        // Step 3)

        // console.log(console.log(fruit[10]))  
        // undefined

        // Step 4)
        // console.log(fruit.length)

        // Step 5) An array can store elements of any type.

        // let arr = ['Apple', { name : "Kamlesh" }, true, function(name) { console.log(this.name); }];
        // console.log(arr[1].name)
        // arr[3]("Rahul");

        // Step 6) 
        
        // console.log(fruit[fruit.length - 1]);
        // console.log(fruit.at(0))

        // Step 7)
        // let rollno = {
        //     1 : "Kamlesh",
        //     2 : "Rahul"
        // }

        // console.log(rollno[1])

        // 1) When you access an array element using arr[0], itâ€™s similar to accessing an object property using obj[key].
        // 2) Here, arr is like an object, and the index 0 is like a key.
        // 3) Arrays are indeed specialized objects. They extend the basic functionality of objects by providing additional methods specifically designed to work with ordered collections of data.
        // 4) Arrays come with built-in methods like push(), pop(), shift(), unshift(), map(), filter(), reduce(), and many more. These methods make it easier to manipulate and work with lists of data.
        // 5) Arrays have a special length property that keeps track of the number of elements in the array. This property is automatically updated as you add or remove elements from the array.
        // 6) Despite having these special features, arrays are still objects at their core. This means they inherit from Object and you can interact with them using the same syntax and principles you use for objects.
        // 7) For instance, you can add properties to an array just like you would with any object: arr.someProperty = someValue.

        // ex  Adding a custom property
        // arr.customProperty = "Hello";
        // console.log(arr.customProperty); // Output: Hello


        // Yes, you are correct. Arrays are optimized for performance because the JavaScript engine tries to store array elements in a contiguous block of memory, which allows for fast access and manipulation. However, treating an array like a regular object can interfere with these optimizations. Let's look at an example to illustrate this:

        // let arr = [1, 2, 3, 4];

        // Adding a property like an object
        // arr.someProperty = "Hello";
        // console.log(arr.someProperty); // Output: Hello

        // Adding a non-numeric key
        // arr["nonNumericKey"] = "World";
        // console.log(arr["nonNumericKey"]); // Output: World

        // The array still works as an array
        // console.log(arr[0]); // Output: 1

        // But now the internal optimizations might be broken
        // console.log(arr.length); // Output: 4

        // *) Misusing Arrays:

        // 1) Adding Non-Numeric Properties: When you add properties that are not numeric indices, such as arr.test = 5, you treat the array like a regular object. This can cause the engine to disable array-specific optimizations.
        // 2) Creating Sparse Arrays: If you create an array with gaps (holes) between elements, such as arr[0] = 'a' and arr[1000] = 'b' without filling the indices in between, the array is no longer contiguous. This breaks the memory optimization.
        // 3) Filling in Reverse Order: Adding elements in reverse order, like starting with arr[1000] and then arr[999], also disrupts the expected sequential order and can lead to inefficient memory usage.

        // *) Best Practices:

        // 1) Ordered Data: Use arrays when you need to work with ordered data. This allows you to take full advantage of their special methods (push, pop, map, filter, etc.) and the internal optimizations that make them fast and efficient.
        // 2) Arbitrary Keys: If you need to use non-numeric keys or store data in a non-sequential manner, it's better to use a regular object ({}) or a Map object, which is designed for key-value pairs and does not rely on contiguous memory storage.

        let arr = [1,2,3,4];
        arr.push(5);
        console.log(arr.length)
    </script>
</body>
</html>