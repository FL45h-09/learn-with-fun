<script>
    'use strict';
    /* ways to write numbers */
    let billion = 1000000000;
    console.log(billion); //1000000000

    let billion_ = 1_00_00_00_000; //JS engine simply ignores _ between digits.
    console.log(billion_); //1000000000

    let realtimebillion = 1e9; //1 billion, literally: 1 and 9 zeroes (1 * 1000000000)
    console.log(realtimebillion); //1000000000

    console.log(5.3e5); //5.3 lac 

    // we have to write 0.000001 (a negative number after "e" means a division by 1 i.e (1/100000) )
    let microseconds = 1.e-6;
    console.log(microseconds); //0.000001

    let decimal = 1234e-2;
    console.log(decimal); //12.34

    
    /* toString(base) */
    let num = 255;
    console.log(num.toString(8));  //octal value 377
    console.log(num.toString(16));  //hex value ff
    console.log('\n');

    
    /* Rounding */
    const mathf = 3.51;
    console.log(Math.ceil(mathf)); //4  round up
    console.log(Math.floor(mathf)); //3 rounds down
    console.log(Math.round(mathf)); //4 rounds the nearest integer
    console.log(Math.trunc(mathf)); //3 Removes anything after the decimal point
    console.log(mathf.toFixed(3)); // 3.510
    console.log(mathf.toFixed(1)); // 3.5
    console.log(typeof(mathf.toFixed(4))); // '3.5100' typeof always "string"
    console.log('\n');
   
    /* Tests: isFinite and isNaN */
    console.log(typeof Infinity); //number
    console.log(isNaN(Infinity)); //false
    console.log(NaN == NaN); //false
    console.log(typeof NaN); //number
    console.log('\n');

    // isFinite(value) converts its argument to a number and returns true if it’s a regular number, not NaN/Infinity/-Infinity:
    console.log(isFinite(1564165151564)); //true
    console.log(isFinite("1564165151564")); //true
    console.log(isFinite("string")); //false, because a special value: NaN
    console.log(isFinite(Infinity)); //false, because a special value: Infinity
    console.log(isFinite(-Infinity)); //false, because a special value: -Infinity
    console.log(isFinite(' ')); //true, because an empty or space-only string is treated as 0 in all numeric functions.
    console.log('\n');

    //Number.isNaN and Number.isFinite (Number.isNaN and Number.isFinite methods are the more “strict” versions of isNaN and isFinite functions. They do not autoconvert their argument into a number, but check if it belongs to the number type instead.)
    console.log(Number.isNaN(NaN)); //true
    console.log(Number.isFinite("str")); //false
    console.log(Number.isFinite("50" / 2)); //true
    console.log(Number.isFinite("50151541")); //false
    console.log(0 == -0); //true
    console.log('\n');
    // let a = 0;
    // let b = 0;
    console.log(Object.is(NaN, NaN)); //true
    console.log(Object.is(0, -0)); //false

</script>