<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>
        'use strict';

        // Numbers

        /* In Modern JavaScript, there are two types of numbers: */
        /* 1. Regular numbers in JS are stored in 64-bit format, also known as "Double Precision Floating Point Numbers". */
        /* 2. BigInt numbers represent integers of arbitrary length. They are sometimes needed because a regular integer number can't safely exceed (2^53 - 1) or be less than -(2^53 - 1). */


        // Different Ways To Write Numbers:
        let onebillion = 1000000000;
        console.log(`One billion: ${onebillion}`);

        /* We also use underscore "_" as the separator: */
        let twobillion = 2_000_000_000;
        console.log(`Two billion: ${twobillion}`);

        /* Here the "underscore (_)" plays the role of the "Syntactic Sugar" (Syntactic sugar is syntax within a programming language that is designed to make things easier to read or to express.) */
        /* It makes the number more readable. The JavaScript engine simply ignores "_" between digits, So in output it will show exactly same as "onbillion". */

        /* To avoid long sequence of zeros, we will try to write numbers like "1bn" for a billion or "7.3bn" for 7 Billion 300 Million. The same is true for most large numbers. */
        /* In JS, we can shorten the number by appending the letter "e" to it and specifying the zeros count. */

        let num1 = 1e9; // 1 billion - 1 and 9 zeros
        console.log(`Num1: ${num1}`);

        /* In other words, "e" multiplies the number by 1 with the given zeros count. */
        // 1e3 === 1*1000;  [e3 means *1000]
        // 1.23e6 === 1.23 * 1000000;  [e6 means *1000000]

        let num2 = 1.23e6;
        console.log(`Num2: ${num2}`); // 1230000


        /* To write very small number: 1 microsecond */
        /* Just like before, using "e". If we had like to avoid writing zeroes explicitely, we could write as follows:  */
        let ms = 1e-6;
        console.log(`Microseconds: ${ms}`);

        /* In other words, a negative number after "e" means a division by 1 with the given number of zeroes. */

        // 1e-3 === 1/1000;  [0.001]
        // 1.23e-6 === 1.23 / 1000000;  [0.00000123]

        /* An example with bigger number */
        // 1234e-2 === 1234 / 100;  [12.34]  (decimal point moves 2 times)



        // Hex, binary and octal numbers

        // Hexadecimal Numbers
        /* "Hexadecimal Numbers" are widely used in JS to represent colors, encode characters, and for many other things. So there is a shorter way to write them: "0x" and then the number */
        let hex1 = (0xff);
        console.log(`Hex1: ${hex1}`); // 255

        let hex2 = (0x3f);
        console.log(`Hex2: ${hex2}`); // 63

        let hex3 = (0x4A3);
        console.log(`Hex3: ${hex3}`); // 1187

        // Binary and Octal Numbers
        /* "Binary and Octal Numbers" systems are rarely used, but also supported using the "0b" and "0o" prefixes: */

        let bin1 = (0b11111111);
        console.log(`Bin1: ${bin1}`); // 255

        let bin2 = (0b01010101);
        console.log(`Bin2: ${bin2}`); // 85

        let oct1 = (0o377);
        console.log(`Oct1: ${oct1}`); // 255

        let oct2 = (0o62146);
        console.log(`Oct2: ${oct2}`); // 25702

        /* Addition */
        console.log(`Addition: ${oct1+oct2}`); // 25957



        // toString(base)
        /* The method "num.toString(base)" returns a string representation of number in numeral system with the given base. */

        let num3 = 255;
        console.log(`Num3: ${num3.toString(16)}`); // ff
        console.log(`Num3: ${num3.toString(2)}`); // 11111111
        console.log(`Num3: ${num3.toString(8)}`); // 377

        let num4 = 2563;
        console.log(`Num4: ${num4.toString(16)}`); // a03
        console.log(`Num4: ${num4.toString(2)}`); // 101000000011
        console.log(`Num4: ${num4.toString(8)}`); // 5003

        /* The base can vary from "2" to "36", by default it's "10". */
        
        /* Common use cases for these are: */
        /* 1. "base=16" is used for hex colors, character encodings etc, digits can be (0 to 9) or (A to F). */
        /* 2. "base=2" is mostly for debugging bitwise operations, digits can be "0" or "1". */
        /* 3. "base=36" is the maximum, digits can be (0 to 9) or (A to Z), The whole latin alphabet is used to represent a number. */

        let num5 = 123456;
        console.log(`Num5: ${num5.toString(36)}`); // 2n9c

        console.log(8530492..toString(36)); // 52u64

        /* The above method is called as "Two Dots to call a Method". */
        /* If we want to call method directly on a number, like "toString", then we need to place two dots after number. */

        console.log((8530492).toString(36));
        /* If we want to use single dot after number, then we nned to add a number in braces. */



        // Rounding
        /* There are several built-in functions for rounding: */

        /* 1. Math.floor */
        /* "Math.floor" round the number to the nearest previous number */
        console.log(`Math.floor of 3.1 = ${Math.floor(3.1)}`); // 3
        console.log(`Math.floor of -1.1 = ${Math.floor(-1.1)}`); // -2

        /* 2. Math.ceil */
        /* "Math.ceil" round the number to the nearest next number */
        console.log(`Math.ceil of 3.1 = ${Math.ceil(3.1)}`); // 4
        console.log(`Math.ceil of -1.1 = ${Math.ceil(-1.1)}`); // -1

        /* 3. Math.round */
        /* "Math.round" rounds the number to the nearest number */
        console.log(`Math.round of 3.1 = ${Math.round(3.1)}`); // 3
        console.log(`Math.round of 3.6 = ${Math.round(3.6)}`); // 4

        /* 4. Math.trunc */
        /* "Math.trunc" removes everything after decimal */
        console.log(`Math.trunc of 3.1 = ${Math.trunc(3.1)}`); // 3
        console.log(`Math.trunc of 3.6 = ${Math.trunc(3.6)}`); // 3
        console.log(`Math.trunc of -1.1 = ${Math.trunc(-1.1)}`); // -1

        /* Here's the table to summarize the difference between above 4 function: */

        /*           Math.floor      Math.ceil       Math.round      Math.trunc     */
        /*   3.1          3               4               3               3         */
        /*   3.6          3               4               4               3         */
        /*  -1.1         -2              -1              -1              -1         */
        /*  -1.6         -2              -1              -2              -1         */   
        
        /* These functions cover all the possible ways to deal with the decimal part of number. */
        console.log(`Round the number to the "n-th" digit`)

        /* Here's the example for "round the number to the "n-th" digit after the decimal" */
        /* For example: we have "1.2345" and want to round it to 2 digits, getting only "1.23" */
        /* There are two ways to do: */
        
        /* 1. Multiply and Divide */
        /* To round the number to the 2nd digit after the decimal, first we multiply number by 100, then we round the number using built-in function, then we divide the rounded number with 100. */
        console.log(`Using Multiply and Divide = ${(Math.round(1.2345*100))/100}`) // 1.23

        /* 2. toFixed(num) */
        /* The method "toFixed(n)" rounds the number to "n" digits after the decimal point and returns a string representation of the result. */
        /* This rounds the number to nearest number, similar to "Math.round". */
        console.log(`Using toFixed = ${1.2345.toFixed(2)}`) // 1.23
        console.log(`Using toFixed = ${1.2385.toFixed(2)}`) // 1.24
        console.log(`Using toFixed = ${typeof(1.2355.toFixed(2))}`) // String

        /* Note: The type of "toFixed()" is a String. */
        /* If the decimal part is shorter than required, then zeroes are automatically appended to the end of number. */
        console.log(`Using toFixed = ${1.23.toFixed(5)}`) // 1.23000



        // Imprecise Calculations

        /* Internally, the number represented in 64 bit format. If a number is really huge, number overflow 64-bit storage and become a special numeric value "Infinity". */
        console.log(`1e500 = ${1e500}`) // Infinity

        console.log(`0.1 + 0.2 == 0.3 >> ${0.1 + 0.2 == 0.3}`); // false
        /* Its because of: */
        console.log(`0.1 + 0.2 = ${0.1 + 0.2}`) // 0.30000000000000004
        /* But why does this happen? */
        /* A number is stored in a memory in its binary form, a sequence of bits-ones and zeroes. */
        /* Fractions like "0.1", "0.2" that look simple in the numeric decimal number system. */

        /* Solution on this is: */
        console.log(`Solution: ${(0.1 + 0.2).toFixed(2)}`); // 0.30



        // Tests: "isFinite" and "isNaN"
        /* "Infinity" is a special numeric value that is greater than anything. */
        /* "NaN" represents an error. */

        /* They belong to type "Number", but are not normal "Numbers" so there are special functions to check for them: */
        
        /* 1. isNaN(value) */
        /* First it converts arguments to a number and then test it for being "NaN". */
        
        console.log(`isNaN()`)
        console.log(isNaN("str")); // true
        console.log(isNaN(NaN)); // true
        console.log(isNaN(1)); // false

        /* 2. isFinite(value) */
        /* First it converts argument to a numner and then returns true or false, "true" if its a regular number, and "false" if its NaN/Infinity. */

        console.log(`isFinite()`)
        console.log(isFinite("str")); // false
        console.log(isFinite(NaN)); // false
        console.log(isFinite(1)); // true
        console.log(isFinite("0.1")); // true

        /* Sometimes "isFinite" is used to check whether the string value is a regular number. */


        // Number.isNaN() & Number.isFinite()
        /* These methods are the more "strict" versions of "isNaN & isFinite" functions. */
        /* They do not autoconvert arguments to the number, but it checks whether if it belongs to the "number" type. */

        /* 1. Number.isNaN() */
        /* It retuns "true" if the argument belongs to "number" type and it is "NaN". */

        console.log(Number.isNaN(NaN)); // true
        console.log(Number.isNaN("str" / 2)); // true
        console.log(Number.isNaN("str")); // false, because "str" belongs to the string type, not the number type.
        console.log(isNaN("str")); // true, because isNaN converts string "str" into a number and gets NaN as a result of this conversion.

        
        /* 2. Number.isFinite() */
        /* It retuns "true" if the argument belongs to "number" type and it is not "NaN/Infinity". */

        console.log( Number.isFinite(123) ); // true
        console.log( Number.isFinite(Infinity) ); // false
        console.log( Number.isFinite(2 / 0) ); // false
        console.log( Number.isFinite("123") ); // false, because "123" belongs to the string type, not the number type
        console.log( isFinite("123") ); // true, because isFinite converts string "123" into a number 123

        /* From the above examples, First "Number.isNaN() & Number.isFinite()" checks the argument is belongs to "number" type or not. If its not belongs to "number" type it returns "false", If its belongs to "number" type then it will go further. */



        // parseInt and parseFloat
        /* Numeric conversion using a "+" or "Number()" is strict. If a value is exactly not a number, it fails. */
        console.log(`parseInt and parseFloat`);
        console.log(+"100"); // 100
        console.log(+"100px"); // NaN

        
    </script>
</body>
</html>