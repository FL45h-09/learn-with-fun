<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>
        'use strict';

        // Arrays

        /* Object allows us to store keyed collection of values. But sometimess we need to store collection of data in "Ordered collection" or in "list format". */
        /* It is not convinient to use object here, because object doesn't provide any methods to manage the order of elements. We can't insert new property "between" the existing ones. */
        /* There exists a special data structure named "Array", to store ordered collections. */


        // Declaration
        /* There are two syntaxes for creating an empty Array */
        let arr1 = new Array();
        let arr2 = [];

        let fruits1 = new Array("Apple", "Mango", "Kiwi");
        console.log(`fruits1: ${fruits1}`);
        let fruits2 = ["Banana", "Lichi", "Grapes"];
        console.log(`fruits2: ${fruits2}`);


        /* Array elements are numbered [indexed], starting with zero. */
        /* We can get element by its number [index] in square brackets. */

        console.log(`fruits1[0]: ${fruits1[0]}`); // Apple
        console.log(`fruits1[1]: ${fruits1[1]}`); // Mango
        console.log(`fruits1[2]: ${fruits1[2]}`); // Kiwi
        console.log(`fruits1[3]: ${fruits1[3]}`); // Undefined

        /* 1. Replace */
        /* We can replace an element: */
        fruits1[0] = "Peach";
        console.log(`Replace: ${fruits1}`); // Peach, Mango, Kiwi

        
        /* 2. Add */
        /* Also, we can add new element to an array: */
        fruits1[3] = "Lemon";
        console.log(`Add: ${fruits1}`); // Peach, Mango, Kiwi, Lemon


        /* 3. arr.length */
        /* We can get total count of elements in the array using "length" */
        console.log(`Length: ${fruits1.length}`); // 4


        /* 4. An array can store elements of any type. */
        let arr = ["Apple", {name: "Abhi"}, true, function(){ alert("Working...")}];

        console.log(`arr[0]: ${arr[0]}`); // Apple

        console.log(`arr[1]: ${arr[1]}`); // [object, Object]
        console.log(`arr[1]: ${arr[1].name}`); // Abhi
        
        console.log(`arr[2]: ${arr[2]}`); // true

        console.log(`arr[3]: ${arr[3]}`) // function(){ alert("Working...")}
        console.log(`arr[3]: ${arr[3]()}`); // alert("Working...")



        // Get Last Elements With "at"
        /* If we want the last element of the array. We can't use negetive index directly. It will throw "undefined". */

        console.log(`Last element: ${fruits1[fruits1.length-1]}`); // Lemon
        console.log(`Last element: ${fruits1[-1]}`); // Undefined

        /* For shorter syntax, we can use ".at()". */
        console.log(`using '.at(-1)': ${fruits1.at(-1)}`); // Lemon
        console.log(`using '.at(1)': ${fruits1.at(1)}`); // Mango

        /* In other words, arr.at(i) */
        /* 1. Is exactly same as "arr[i]", if "i >= 0". */
        /* 2. For negative values of "i", it starts from the end of an array. */



        // Methods => pop/push, shift/unshift
        
        /* shift: Remove an element from the beginning of an array. */
        /* unshift: Add an element to the beginning of an array. */

        /* pop: Remove an element from end of an array. */
        /* push: Add an element to the end of an array. */

        let num = ["A", "B", "C", "D", "E", "F"];
        console.log(`shift: ${num.shift()}, Arr: ${num}`); // shift: A, Arr: B,C,D,E,F
        console.log(`unshift: ${num.unshift("A")}, Arr: ${num}`); // unshift: 6, Arr: A,B,C,D,E,F
        console.log(`pop: ${num.pop()}, Arr: ${num}`); // pop: F, Arr: A,B,C,D,E
        console.log(`push: ${num.push("F")}, Arr: ${num}`); // push: 6, Arr: A,B,C,D,E,F

        /* "shift" & "pop" returns the element which is removed. */
        /* "unshift" & "push" returns the new length of the array. */



        // Internals

        let demo1 = [];
        demo1[99] = 5;
        demo1.name = "demo1";
        console.log(`Internals: ${demo1[99]}`); // 5
        console.log(`Internals: ${demo1[98]}`); // undefined
        console.log(`Internals: ${demo1.name}`); // demo1



        // Loops
        /* One of the oldest ways to cycle array items is the "for" loop over indexes: */
        for(let i=0; i<num.length; i++){
            console.log(`for loop: ${num[i]}`);
        }

        /* We can also use another form of loops */
        for(let key in num){
            console.log(`for..in loop: ${num[key]}`);
        }

        for(let key of num){
            console.log(`for..of loop: ${key}`);
        }

        /* The "for..of" doesn’t give access to the number of the current element, just its value, but in most cases that’s enough. And it’s shorter. */



        // length
        /* The "length" property automatically updates when we modify the array. */
        /* To be precise, it is actually not the count of values in the array, but the greatest numeric index plus one. */
        
        let demo2 = [];
        demo2[99] = 1;
        console.log(`length: ${demo2.length}`); //100

        /* The above example is only for practice. */

        /* Another interesting thing about the "length" property is that it’s writable. */
        /* If we increase it manually, nothing interesting happens. But if we decrease it, the array is truncated. The process is irreversible, here’s the example: */

        let nums = [1,2,3,4,5];
        nums.length = 3;
        console.log(`nums.length = 3 => ${nums}`); // 1,2,3
        nums.length = 4;
        console.log(`nums.length = 4 => ${nums}`); // 1,2,3,
        console.log(`nums.length[3] = 4 => ${nums[3]}`); // undefined  [Here, the third index is undefied beacause we already truncated the "nums" array width length 3.]

        /* The simplest way to clear the array is "arr.length=0" */
        nums.length = 0;
        console.log(`nums.length = 0 => ${nums}`) // Empty
        console.log(`nums.length[0] = 0 => ${nums[0]}`) // undefined



        // new Array()
        /* There is one more syntax to create an array: */
        let newArray1 = new Array(1,2,3,4,5);
        console.log(`newArray1 = ${newArray1}`) // 1,2,3,4,5


        /* If "new Array()" is called with a single argument which is a number, then it creates an array without items, but the single argument becomes the length of that array. */
        let newArray2 = new Array(4);
        console.log(`newArray2 = ${newArray2}`) // ,,,
        console.log(`newArray2.length = ${newArray2.length}`) // 4

        /* To avaoid this, use square brackets. */



        // Multidimensional Arrays
        /* Arrays can have items that are also arrays. We can use it for multidimensional arrays, for example to store matrices: */
        let matrix = [
            [1,2,3],
            [4,5,6],
            [7,8,9]
        ];
        console.log(`matrix[2][2]: ${matrix[2][2]}`) // 9



        // toString
        /* Arrays have their own implementation of "toString" method that returns a comma-separated list of elements. */
        let newArr = [1,2,3,4,5];

        console.log(`toString: ${String(newArr)}`);
        console.log(`toString: ${typeof(String(newArr[0]))}`); // string

        /* Another method */
        console.log([]+1); // 1
        console.log([]+2); // 2
        console.log([1]+1); // 11
        console.log([1,2]+1); // 1,21
        console.log(typeof([1,2]+1)); // string



        // Don't compare arrays with "=="
        /* Arrays in JavaScript, shouldn’t be compared with operator "==". */
        /* Rules for the arryas: */
        /* 1. Two objects are equal "==", only if they're references to the same object. */
        /* 2. If one of the arguments of "==" is an object, and the other one is a primitive, then the object gets converted to primitive. For example: */

        let obj = [1,3];
        console.log(obj+1); // 1,31
        console.log(typeof(obj+1)); // string

        /* 3. With an exception of "null" and "undefined" that equal "==" each other and nothing else. */

        let obj2 = [];
        console.log(obj2);
        console.log(obj2==null); // false  [its false because the reference of object memory called]
        console.log(obj2==undefined); // false
        console.log(obj2[0]==null); // true
        console.log(obj2[0]==undefined); // true


        /* So, if we compare arrays with "==", they are never the same, unless we compare two variables that reference exactly the same array. */
        let Arr1 = [1,2,3];
        let Arr2 = [1,2,3];
        console.log(Arr1==Arr2); // false
        console.log(Arr1[0]==Arr2[0]); // false

        /* These arrays are technically different objects. So they aren't equal. The "==" operator doesn't do  item-by-item comparison. */

        /* Comparison with primitives may give strange result as well: */
        console.log(0==[]) // true
        console.log('0'==[]) // false
        console.log('0'==['0']) // true

        /* Here, in both cases, we compare a primitive with an array object, So the "array" gets converted to "primitive" for the purpose of comparison and becomes an empty string. */
        /* Then the comparison process goes on with the primitives. */
        
        /* after [] (Array) was converted to "" (String) */
        /* For example on li 233:- It returns true, First array converted to primitive, then as '' becomes converted to number 0. */
        /* For example on li 234:- It returns false, First array converted to primitive, then no type conversions because of different strings. */

        /* To compare arrays, don't use "==" operator directly, Instead of this, compare array item-by-item. */
    </script>
</body>
</html> 